head	1.13;
access;
symbols
	MLW_daveb_inline_1_4_99:1.13.1
	MLWorks_21c0_1999_03_25:1.13
	MLWorks_20c1_1998_08_20:1.11
	MLWorks_20c0_1998_08_04:1.11
	MLWorks_20b2c2_1998_06_19:1.11
	MLWorks_20b2_Windows_1998_06_12:1.11
	MLWorks_20b1c1_1998_05_07:1.10
	MLWorks_20b0_1998_04_07:1.9
	MLWorks_20b0_1998_03_20:1.9
	MLWorks_20m2_1998_02_16:1.8
	MLWorks_MM_adapt:1.7.3
	MLWorks_20m1_1997_10_23:1.7
	MLWorks_11r1:1.6.1.1.1.1.1
	MLWorks_workspace_97:1.7.2
	MLWorks_dt_wizard:1.7.1
	MLWorks_11c0_1997_09_09:1.6.1.1.1.1
	MLWorks_10r3:1.6.1.1.3
	MLWorks_10r2_551:1.6.1.1.2
	MLWorks_11:1.6.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.6.1.1
	MLWorks_20m0_1997_06_20:1.7
	MLWorks_1_0_r2c2_1997_06_14:1.6.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.6.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.6.1
	MLWorks_BugFix_1997_04_24:1.7
	MLWorks_1_0_r2_Win32_1997_04_11:1.6
	MLWorks_1_0_r2_Unix_1997_04_04:1.6
	MM_ML_release_korma_1997_04_01:1.6
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.4.4.2.1
	MLWorks_gui_1996_12_18:1.4.5
	MLWorks_1_0_Win32_1996_12_17:1.4.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.4.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.4.1.1
	JFHrts:1.4.3
	MLWorks_1_0_Irix_1996_11_28:1.4.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.4.2
	MLWorks_1_0_Unix_1996_11_14:1.4.1
	MLWorks_Open_Beta2_1996_10_11:1.1.3
	MLWorks_License_dev:1.1.2
	MLWorks_1_open_beta_1996_09_13:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	98.10.16.14.08.52;	author jont;	state Exp;
branches
	1.13.1.1;
next	1.12;

1.12
date	98.09.16.11.57.05;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	98.06.12.14.39.23;	author jkbrook;	state Exp;
branches;
next	1.10;

1.10
date	98.04.14.13.37.28;	author mitchell;	state Exp;
branches;
next	1.9;

1.9
date	98.02.23.18.22.48;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	97.11.26.10.09.28;	author johnh;	state Exp;
branches;
next	1.7;

1.7
date	97.04.11.14.03.22;	author jont;	state Exp;
branches
	1.7.1.1
	1.7.2.1
	1.7.3.1;
next	1.6;

1.6
date	97.03.10.09.11.54;	author stephenb;	state Exp;
branches
	1.6.1.1;
next	1.5;

1.5
date	96.12.23.15.52.04;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	96.10.25.15.05.26;	author nickb;	state Exp;
branches
	1.4.1.1
	1.4.2.1
	1.4.3.1
	1.4.4.1
	1.4.5.1;
next	1.3;

1.3
date	96.10.23.12.46.53;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	96.10.17.13.15.34;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	96.08.27.16.29.51;	author nickb;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	96.09.13.11.23.06;	author hope;	state Exp;
branches;
next	;

1.1.2.1
date	96.10.07.16.13.15;	author hope;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	96.10.09.12.16.23;	author nickb;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	96.10.15.14.44.49;	author jont;	state Exp;
branches;
next	;

1.1.3.1
date	96.10.17.11.32.32;	author hope;	state Exp;
branches;
next	;

1.4.1.1
date	96.11.14.12.58.27;	author hope;	state Exp;
branches
	1.4.1.1.1.1;
next	1.4.1.2;

1.4.1.2
date	96.12.23.18.27.00;	author jont;	state Exp;
branches;
next	;

1.4.1.1.1.1
date	96.11.28.15.08.23;	author hope;	state Exp;
branches;
next	1.4.1.1.1.2;

1.4.1.1.1.2
date	96.12.23.17.21.41;	author jont;	state Exp;
branches;
next	;

1.4.2.1
date	96.11.22.18.16.05;	author hope;	state Exp;
branches;
next	;

1.4.3.1
date	96.12.17.10.02.48;	author hope;	state Exp;
branches;
next	;

1.4.4.1
date	96.12.17.17.54.30;	author hope;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	97.01.02.14.46.57;	author jont;	state Exp;
branches
	1.4.4.2.1.1;
next	;

1.4.4.2.1.1
date	97.02.24.11.45.35;	author hope;	state Exp;
branches;
next	;

1.4.5.1
date	96.12.18.09.49.05;	author hope;	state Exp;
branches;
next	;

1.6.1.1
date	97.05.12.10.41.30;	author hope;	state Exp;
branches
	1.6.1.1.1.1
	1.6.1.1.2.1
	1.6.1.1.3.1;
next	;

1.6.1.1.1.1
date	97.07.28.18.25.34;	author daveb;	state Exp;
branches
	1.6.1.1.1.1.1.1;
next	;

1.6.1.1.1.1.1.1
date	97.10.07.11.51.25;	author jkbrook;	state Exp;
branches;
next	;

1.6.1.1.2.1
date	97.09.08.17.18.48;	author daveb;	state Exp;
branches;
next	;

1.6.1.1.3.1
date	97.09.09.14.14.56;	author daveb;	state Exp;
branches;
next	;

1.7.1.1
date	97.09.10.19.31.43;	author brucem;	state Exp;
branches;
next	;

1.7.2.1
date	97.09.11.21.01.07;	author daveb;	state Exp;
branches;
next	;

1.7.3.1
date	97.10.31.13.44.07;	author nickb;	state Exp;
branches;
next	;

1.13.1.1
date	99.04.01.18.00.59;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Portable main.c at last.
@


1.13
log
@[Bug #70207]
Move start_mlworks into separate file
@
text
@/*  === TOP LEVEL OF RUNTIME SYSTEM ===
 *
 *  Copyright (C) 1996 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This file contains the main() function, which parses the command
 *  line and performs actions accordingly.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:main.c,v $
 * Revision 1.12  1998/09/16  11:57:05  jont
 * [Bug #30108]
 * Add extra parameters to run_scheduler for DLL work
 *
 * Revision 1.11  1998/06/12  14:39:23  jkbrook
 * [Bug #30411]
 * Add command-line option to behave as Free edition
 *
 * Revision 1.10  1998/04/14  13:37:28  mitchell
 * [Bug #50061]
 * Reverse treatment of command-line argument passing for executables with embedded image
 *
 * Revision 1.9  1998/02/23  18:22:48  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
 * Revision 1.8  1997/11/26  10:09:28  johnh
 * [Bug #30134]
 * add extra arg to save_excutable.
 *
 * Revision 1.7  1997/04/11  14:03:22  jont
 * [Bug #1833]
 * Change instances of "modules" in runtime usage message to "object files"
 *
 * Revision 1.6  1997/03/10  09:11:54  stephenb
 * [Bug #1925]
 * stop_mlworks: set the messager_function to NULL before a message
 * is output so that the message always goes to the tty.
 *
 * Revision 1.5  1996/12/23  15:52:04  jont
 * [Bug #1880]
 * Remove expiry date protection checking from MLWorks
 *
 * Revision 1.4  1996/10/25  15:05:26  nickb
 * Change explorer entry.
 * .,
 *
 * Revision 1.3  1996/10/23  12:46:53  jont
 * [Bug #1693]
 * Don't hang on license failure when running in batch mode
 *
 * Revision 1.2  1996/10/17  13:15:34  jont
 * Merging in license server stuff
 *
 * Revision 1.1.2.3  1996/10/15  14:44:49  jont
 * Release the license when terminating
 *
 * Revision 1.1.2.2  1996/10/09  12:16:23  nickb
 * Name change: license -> license_init.
 *
 * Revision 1.1.2.1  1996/10/07  16:13:15  hope
 * branched from 1.1
 *
 * Revision 1.1  1996/08/27  16:29:51  nickb
 * new unit
 * Portable main.c at last.
 *
 */

#include <stdlib.h>
#include "threads.h"
#include "mlw_start.h"
#include "values.h"
#include "main.h"

int main(int argc, const char *const *argv)
{
  run_scheduler(start_mlworks, argc, argv, MLUNIT, NULL);
  return (EXIT_SUCCESS);
}
@


1.13.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a12 4
 * Revision 1.13  1998/10/16  14:08:52  jont
 * [Bug #70207]
 * Move start_mlworks into separate file
 *
@


1.12
log
@[Bug #30108]
Add extra parameters to run_scheduler for DLL work
@
text
@d13 4
d73 3
a75 9
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "ansi.h"

#include "types.h"
#include "mltypes.h"

a76 20
#include "profiler.h"
#include "license.h"
#include "options.h"
#include "mem.h"
#include "gc.h"
#include "loader.h"
#include "image.h"
#include "global.h"
#include "utils.h"
#include "allocator.h"
#include "interface.h"
#include "initialise.h"
#include "os.h"
#include "print.h"
#include "exec_delivery.h"
#include "pervasives.h"
#include "diagnostic.h"
#include "explore.h"
#include "environment.h"

a77 777

#ifndef MACH_FIXUP
  #ifdef MEASURE_FIXUP
    #include "fixup.h"
  #endif
#endif

static const char usage_message[] =
  "Usage:   %s [options...] object file...\n"
  "Options:\n"
  "\n"
  " Object File Options:\n"
  "  --      This option does nothing, but nothing after it on the command \n"
  "          line will be treated as an option.\n"
  "  -load <file>\n"
  "          Load an image from <file> before loading any object files.\n"
  "  -from <file>\n"
  "          Read object file names from <file> before reading them from\n"
  "          the command line.\n"
  "  -save <file>\n"
  "          After loading the specified object files, save the image in <file>.\n"
  "  -pass <s> arg... <s>\n"
  "          Propagate arguments between the delimiter strings <s> to the\n"
  "          object files. <s> may be any string.\n"
  "\n"
  " Memory Management Options:\n"
  "  -c <n>  Report garbage collections at level <n> and above.\n"
  "  -limit <n>\n"
  "          Specifies an advisory arena extent size in Mb (default 100).\n"
  "          Collection frequency will increase as the amount of\n"
  "          virtual memory used by the process approaches this amount.\n"
  "  -stack <n>\n"
  "          Set initial maximum number of stack blocks to <n>.\n"
  "  -batch  Run in non-interactive mode; i.e. do not prompt when\n"
  "          virtual memory is exhausted.\n"
  "\n"
  " Profiling Options:\n"
  "  -profile <file>\n"
  "          Profile the entire run, writing the results to <file>.\n"
  "  -profile-scan <n>\n"
  "          When profiling, scan the stack every <n> milliseconds to\n"
  "          gather information.  An interval of zero disables scanning.\n"
  "          The default is 10 milliseconds.\n"
  "  -profile-depth <n>\n"
  "          When profiling with scanning, record patterns of caller\n"
  "          functions to a depth of <n> callers.  The default is zero.\n"
  "  -profile-select <s>\n"
  "          When profiling, only record information about functions which\n"
  "          include <s> in their names.  By default, all functions are\n"
  "          profiled.\n"
  "  -profile-manner <n>\n"
  "          A bit-pattern specifying which kind of profiling to do\n"
  "          Relevant bits are:-\n"
  "          Bit 0 - set for call counting\n"
  "          Bit 1 - set for time profiling\n"
  "          Bit 2 - set for space profiling\n"
  "          Bit 3 - set for space profile copying analysis\n"
  "                  (survival times for allocated values)\n"
  "          Bits 8-15 - set for space profile runtime type analysis\n"
  "                  (analysis broken down according to \"type\")\n"
  "          The default is 7 (i.e. time + space + call-counting)\n"
  "\n"
  " Miscellaneous Options:\n"
  "  -mono   Use the X resources for a monochrome screen (Unix only).\n"
  "  -verbose\n"
  "          Display some messages about runtime activities.\n"
  "  -statistics\n"
  "          Display various internal statistics at the end of the run.\n"
  "  -free-edition\n"
  "          Behave as a free edition (i.e., as if no license available).\n"
  "  -help   Display this message and exit.\n"

#ifdef DEBUG
  "\n"
  " Debugging Runtime Only:\n"
#ifdef DIAGNOSTICS
  "  -d <n>  Set diagnostic level to <n>.\n"
#endif /* DIAGNOSTICS */
  "  -delivery\n"
  "          Abbreviate code vector names on loading.\n"
  "  -image-analysis\n"
  "          Print a heap analysis when loading an image file.\n"
#ifdef EXPLORER
  "  -explore\n"
  "          Run the heap explorer on the global root.\n" 
#endif /* EXPLORER */
  "\n"
  " Hidden Options:\n"
  "  -relaxed\n"
  "          Do not check consistency of object file time stamps.\n"
  "  -no-load-exec\n"
  "          Do not load the heap image (for a saved executable).\n"
  "  -save-exec <file>\n"
  "          Save as an executable in <file>.\n"
  "  -backtrace-depth <depth>\n"
  "          Maximum depth of the backtrace for an uncaught exception.\n"
  "  -show   Display the result of the final object file.\n"
  "  -print <depth> <length> <indent> <tags>\n"
  "          Control the way values are output. This only affects (a) -show\n"
  "          (b) uncaught exception args, (c) MLWorks.Internal.Value.print.\n"
  "          <depth> is the maximum nesting of structures (zero for no\n"
  "          limit), <length> is the maximum length of strings (also zero\n"
  "          for no limit), <indent>, if non-zero, causes values to be\n"
  "          printed on separate lines using indentation to show structure\n"
  "          <tags>, if non-zero, causes internal value information to be\n"
  "          displayed. Defaults are all zero.\n"
  "  -gc-statistics filename\n"
  "          Write garbage collection statistics to file.\n"

#endif /* DEBUG */
;

static struct option
/* Module Options */
  option_load            = {"load", 1, 0, NULL},
  option_modules         = {"from", 1, 0, NULL},
  option_save            = {"save", 1, 0, NULL},
  option_pass	         = {"pass", -1, 0, NULL},

/* Memory Management Options */
  option_messages        = {"c", 1, 0, NULL},
  option_limit           = {"limit", 1, 0, NULL},
  option_stacksize       = {"stack", 1, 0, NULL},
  option_batch           = {"batch", 0, 0, NULL},

/* Profiling Options */
  option_profile         = {"profile", 1, 0, NULL},
  option_profile_scan    = {"profile-scan", 1, 0, NULL},
  option_profile_depth   = {"profile-depth", 1, 0, NULL},
  option_profile_select  = {"profile-select", 1, 0, NULL},
  option_profile_manner  = {"profile-manner", 1, 0, NULL},

/* Miscellaneous Options */
  option_mono	         = {"mono", 0, 0, NULL},
  option_verbose         = {"verbose", 0, 0, NULL},
  option_statistics      = {"statistics", 0, 0, NULL},
  option_free_edition    = {"free-edition", 0, 0, NULL},
  option_help            = {"help", 0, 0, NULL},

/* Hidden Options */
  option_dont_check      = {"relaxed", 0, 0, NULL}, 
  option_no_load_exec    = {"no-load-exec", 0, 0, NULL},
  option_save_exec       = {"save-exec", 1, 0, NULL},
  option_backtrace_depth = {"backtrace-depth", 1, 0, NULL},
  option_show	         = {"show", 0, 0, NULL},
  option_print           = {"print", 4, 0, NULL},
  option_gc_stats        = {"gc-statistics", 1, 0, NULL},

/* Debugging Options */
#ifdef DIAGNOSTICS
  option_diagnostic      = {"d", 1, 0, NULL},
#endif
#ifdef DEBUG
  option_delivery        = {"delivery", 0, 0, NULL},
  option_analysis        = {"image-analysis", 0, 0, NULL},
#endif
#ifdef EXPLORER
  option_explore         = {"explore", 0, 0, NULL},
#endif
  option_end	         = {NULL, 0, 0, NULL};

static struct option *options[] =
{
/* Module Options */
 &option_load, &option_modules, &option_save, &option_pass,

/* Memory Management Options */
 &option_messages, &option_limit, &option_stacksize, &option_batch,

/* Profiling Options */
 &option_profile, &option_profile_scan, &option_profile_depth,
 &option_profile_select, &option_profile_manner,

/* Miscellaneous Options */
 &option_mono, &option_verbose, &option_statistics, &option_free_edition, 
 &option_help,

/* Hidden Options */
 &option_dont_check, &option_no_load_exec, &option_save_exec,
 &option_backtrace_depth, &option_show, &option_print, &option_gc_stats,

/* Debugging Options */
#ifdef DIAGNOSTICS
 &option_diagnostic,
#endif
#ifdef DEBUG
 &option_delivery, &option_analysis,
#endif
#ifdef EXPLORER
 &option_explore,
#endif
 &option_end
};

static struct option
  option_epass	         = {"MLWpass", -1, 0, NULL};

static struct option *embedded_options[] =
{ &option_epass, &option_end };

mlval image_continuation = MLUNIT;

int module_argc = 0;
const char *const *module_argv = NULL;

int mono = 0;
const char *runtime;

static clock_t start = 0, stop = 0;

/*  == Load and link a module and add it to the module table ==
 *
 *  The module is loaded onto the heap by load_module() and linked by
 *  calling the resulting top-level function.
 */

static mlval load_link(const char *filename)
{
  mlval mod_name = MLUNIT;
  mlval result = internal_load_link (filename, &mod_name,
				     option_verbose.specified, 
				     option_dont_check.specified,
#ifdef DEBUG
				     option_delivery.specified
#else
				     0
#endif
				     );
  if(result == MLERROR)
    switch(errno)
    {
      case ELOADREAD:
      error("The loader was unable to read from the file `%s' "
	    "despite being able to open it.", filename);

      case ELOADOPEN:
      error("The loader was unable to open the file `%s'.", filename);

      case ELOADALLOC:
      error("The loader was unable to allocate enough memory while "
	    "loading the file `%s'.", filename);

      case ELOADVERSION:
      error("The file `%s' contains a module of a version the loader does "
	    "not understand.", filename);

      case ELOADFORMAT:
      error("The file `%s' is not in the correct loader format.", filename);

      case ELOADEXTERNAL:
      error("The module in the file `%s' references an unloaded external "
	    "module called `%s'.", filename, CSTRING(load_external));

      default:
      error("The loader returned %d, which is not a valid error code.", errno);
    }
  else
    return(result);
}

/* == Profiling == */

#define DEFAULT_PROFILE_INTERVAL	10
#define DEFAULT_PROFILE_DEPTH		0

static FILE *profile_stream;
static const char *profile_selector = NULL;
static int profile_specified_manner = 0;

static int profile_manner(mlval code)
{
  if(profile_selector == NULL ||
     strstr(CSTRING(CCODENAME(code)), profile_selector) != NULL)
    return profile_specified_manner;
  else
    return 0;
}

/* Now we define a function to be called when MLWorks exits. */

static void stop_mlworks(void)
{
  /* if we have not completed the load process, stop will still be 0 */
  if (stop == 0)
    stop = clock();

  /* if we're profiling... */

  if(option_profile.specified) {
    mlval discard;
    profile_end(&discard);
    if (discard != MLUNIT)
      error("Bad return value from the profiler.");
    if(fclose(profile_stream) == EOF)
      error("Unable to close profiler output file.");
  }

  /* GC statistics stream has to be flushed */
  if(gc_stat_stream != NULL)
    if(fclose(gc_stat_stream) == EOF)
      error("Unable to close statistics file.");

  /* and some statistics to be printed */
  if(option_verbose.specified || option_statistics.specified) {
    messager_function= NULL;
    message("Total loading time %lums.",
	    (long)(((double)(stop - start))*1000.0/(CLOCKS_PER_SEC)));
#ifdef COLLECT_STATS
    printf("Runtime system statistics:\n"
	   "  Raise count: %u\n"
	   "  Stack extension count: %u\n"
	   "  Maximum transient arena size: %ldk\n"
	   "  Maximum heap size: %ldk\n",
	   raise_count, stack_extension_count,
	   (long)(max_arena_extent>>10), (long)(max_heap_size>>10));
#endif
  }

#ifndef MACH_FIXUP
  #ifdef MEASURE_FIXUP
  report_fixup();
  #endif
#endif
  license_release();
}

/* Now the main function run in the top thread */

static int start_mlworks(int argc, const char *const *argv, mlval setup, void (*declare)(void))
{
  int loop;
  mlval result = MLUNIT;
  struct profile_options profile_options;
  int embedded_image;
  int option_parse_status;

  runtime = argv[0];

  --argc; ++argv;	/* Skip the command name argument */

  embedded_image = (load_heap_from_executable(&result, runtime, 1) == 0);

  if (embedded_image) {
    option_parse_status = option_parse(&argc, &argv, embedded_options);

    if (!option_parse_status && (errno == EOPTIONDELIM))
      error("Missing closing delimiter for option `%s'.", argv[0]);

    module_argc = argc; module_argv = argv;
    if (option_epass.specified)
      option_parse_status = option_parse(&option_epass.nr_arguments, 
                                         &option_epass.arguments, options);
    else
      option_parse_status = 1;
  } else {
    option_parse_status = option_parse(&argc, &argv, options);
  }

  if(!option_parse_status)
    switch(errno)
    {
      case EOPTIONARGS:
      error("The wrong number of arguments were specified for the "
	    "option `%s'.  Use `-help' for help.", argv[0]);

      case EOPTIONUNKNOWN:
      error("An unknown option `%s' was specified.  Use `-help' for help.", argv[0]);

      case EOPTIONDELIM:
      error("Missing closing delimiter for option `%s'.  Use `-help' for help.", argv[0]);

      default:
      error("The option parser returned an unknown error code %d.", errno);
    }

  /* Handle a couple of options before initializing the runtime */

  if (option_help.specified) {
    printf(usage_message, runtime);
    exit(EXIT_SUCCESS);
  }

#ifdef DIAGNOSTICS
  if(option_diagnostic.specified)
    diagnostic_level = to_unsigned(option_diagnostic.arguments[0]);
#endif

#ifdef LICENSE
  license_init();
#endif

  /* Now we're ready to initialize the runtime */

  initialise();

  /* Right, now handle the simple options before loading an image */

  if (option_backtrace_depth.specified)
    max_backtrace_depth = to_int(option_backtrace_depth.arguments[0]);

  if (option_batch.specified) {
    license_failure_hang = 0;
  } else {
    out_of_memory_dialog = standard_out_of_memory_dialog;
  }

  if (option_limit.specified)
    arena_limit = to_unsigned(option_limit.arguments[0]) << 20;

  if (option_mono.specified)
    mono = 1;

  if (option_pass.specified) {
    if (embedded_image)
      error("The option `-pass' should not be used with an executable "
            "containing an embedded image.");
    if(option_verbose.specified)
      message("Passing arguments to modules.");

    module_argc = option_pass.nr_arguments;
    module_argv = option_pass.arguments;
  }

  if (option_gc_stats.specified) {
    gc_stat_stream = fopen(option_gc_stats.arguments[0], "w");

    if(gc_stat_stream == NULL)
      error("Unable to open `%s' for writing.", option_gc_stats.arguments[0]);

    if(option_verbose.specified) {
      message_start();
      message_string("Writing garbage collection statistics to file `");
      message_string (	      option_gc_stats.arguments[0]);
      message_string("'.");
      message_end();
    }
  }

  if(option_print.specified) {
    print_defaults.depth_max = to_int(option_print.arguments[0]);
    print_defaults.string_length_max = to_unsigned(option_print.arguments[1]);
    print_defaults.indent = to_int(option_print.arguments[2]);
    print_defaults.tags = to_int(option_print.arguments[3]);
  }

  if (option_free_edition.specified) {
    act_as_free = 1;
  } else {
    act_as_free = 0;
  };


  /* Load initial image */
  /* First try for an image in the executable, if not prohibited */
  /* If none found, load from command line if one specified */
  {
    mlval root;
    int loaded = 1;
    if (!option_no_load_exec.specified && embedded_image) {
      loaded = load_heap_from_executable(&root, runtime, 0);
    }
    if (loaded == 1) { /* no heap in the executable */
      if(option_load.specified) {

	if(option_verbose.specified) {
	  message_start();
	  message_string("Loading image from file `");
	  message_string (	      option_load.arguments[0]);
	  message_string("'.");
	  message_end();
	}

	root = image_load(ml_string(option_load.arguments[0]));
    
	if(root == MLERROR)
	  switch(errno) {
	  case EIMPL:
	    error("Image loading is not implemented by this storage manager.");

	  case EIMAGEFORMAT:
	    error("The file `%s' is not in the correct image format.",
		  option_load.arguments[0]);

	  case EIMAGEOPEN:
	    error("The image loader was unable to open the file `%s'.",
		  option_load.arguments[0]);

	  case EIMAGEREAD:
	    error("The image loader was unable to read from the file `%s' "
		  "despite being able to open it.", option_load.arguments[0]);

	  case EIMAGEALLOC:
	    error("The image loader was unable to allocate enough memory "
		  "while loading the file `%s'.", option_load.arguments[0]);

	  case EIMAGEVERSION:
	    error("The image file `%s' is incompatible with the current "
		  "version of the image loader.", option_load.arguments[0]);

	  default:
	    error("The image loader returned %d, "
		  "which is not a valid error code.", errno);
	  }

#ifdef DEBUG
	if (option_analysis.specified)
	  gc_analyse_heap();
#endif
	loaded = 0; /* Success loading image */
      }
    } else if (loaded == 2) { /* An error occurred loading from executable */
      switch(errno) {
      case EIMAGEFORMAT:
	error("The file `%s' is not in the correct image format.",
	      runtime);

      case EIMAGEOPEN:
	error("The image loader was unable to open the file `%s'.",
	      runtime);

      case EIMAGEREAD:
	error("The image loader was unable to read from the file `%s' "
	      "despite being able to open it.", runtime);

      case EIMAGEALLOC:
	error("The image loader was unable to allocate enough memory while "
	      "loading the file `%s'.", runtime);

      case EIMAGEVERSION:
	error("The image file `%s' is incompatable with the current version "
	      "of the image loader.", runtime);

      default:
	error("The image loader returned %d, "
	      "which is not a valid error code.", errno);
      }
    }
    if(loaded == 0) { /* successfully loaded a heap */
      global_unpack(root);
#ifdef EXPLORER
      if (option_explore.specified)
	if (explore(root, 1))
	  exit(EXIT_SUCCESS);
#endif
    }
  }

  /* We have our heap; look at the remaining options */

  if (option_messages.specified)
    MLUPDATE(gc_message_level, 0, MLINT(to_int(option_messages.arguments[0])));

  if (option_stacksize.specified)
    MLUPDATE(max_stack_blocks, 0,
	     MLINT(to_int(option_stacksize.arguments[0])));

  if (option_profile.specified) {
    const char *filename = option_profile.arguments[0];
    int profile_depth;

    profile_stream = fopen(filename, "w");

    if(profile_stream == NULL)
      error("Unable to open `%s' for writing the profile.", filename);

    profile_selector =
      option_profile_select.specified ?
	option_profile_select.arguments[0] : NULL;

    profile_depth =
      option_profile_depth.specified ?
      to_unsigned(option_profile_depth.arguments[0]) :
      DEFAULT_PROFILE_DEPTH;

    if (profile_depth > PROFILE_DEPTH_MAX)
      error("The profiler cannot profile to depth %d (max %d)",
	    profile_depth, PROFILE_DEPTH_MAX);

    profile_specified_manner = 
      (option_profile_manner.specified ?
       to_unsigned(option_profile_manner.arguments[0]) : PROFILE_ALL) +
	 (profile_depth << PROFILE_DEPTH_SHIFT);

    profile_options.interval =
      option_profile_scan.specified ?
      to_unsigned(option_profile_scan.arguments[0]) :
      DEFAULT_PROFILE_INTERVAL;

    profile_options.manner = profile_manner;

    profile_options.stream = profile_stream;

    if(option_verbose.specified) {
      message_start();
      message_string("Profiling to `");
      message_string(filename);
      message_content("' with scanning interval %u and depth %u.",
		      profile_options.interval, profile_depth);
      message_end();
    }

    if(profile_begin(&profile_options))
      error("The profile returned an unexpected error code %d.", errno);
  } else if (option_profile_scan.specified ||
	     option_profile_depth.specified ||
	     option_profile_select.specified ||
	     option_profile_manner.specified) {
    error("Profiling option given without -profile");
  }
      
  /* install the exit routines in case the image calls MLWorks.exit() */

  os_on_exit(stop_mlworks);

  start = clock();

  /* If an image with a continuation was loaded, execute it first. */
  if(image_continuation != MLUNIT) {
    result = image_continuation;
    image_continuation = MLUNIT;
    result = callml(MLUNIT, result);
  }

  /* If there is a module list file, load modules from there first. */
  if (option_modules.specified) {
    char filename[FILENAME_MAX+1];
    char format[10];
    FILE *f;

    if(option_verbose.specified) {
      message_start();
      message_string("Reading module filenames from file `");
      message_string(option_modules.arguments[0]);
      message_string("'.");
      message_end();
    }

    f = fopen(option_modules.arguments[0], "r");
    
    if(f == NULL)
      error("Unable to open module list file `%s'.",
	    option_modules.arguments[0]);

    (void)sprintf(format, " %%%us", FILENAME_MAX);

    while(fscanf(f, format, filename) == 1) {
      int c = fgetc(f);

      result = load_link(filename);
      
      if(c == EOF)
	break;
      else if(!isspace(c))
	error("Overlong filename in module list file `%s'.",
	      option_modules.arguments[0]);
    }
    
    (void)fclose(f);
  }
  
  /* Load any modules specified on the command line. */
  for(loop=0; loop<argc; ++loop)
    result = load_link(argv[loop]);

  stop = clock();

  /* Show the result of loading the last module */

  if (option_show.specified) {
    print(NULL, stdout, result);
    putchar('\n');
  }

  /* Save the resulting image */
  if(option_save.specified) {
    mlval global, filename, argument;

    if(option_verbose.specified) {
      message_start();
      message_string("Saving image to file `");
      message_string(option_save.arguments[0]);
      message_string("'");
      message_end();
    }

    global = global_pack(0);	/* 0 = not delivery */
    declare_root(&global, 1);
    filename = ml_string(option_save.arguments[0]);
    declare_root(&filename, 1);

    { /* verbosely collect all */
      mlval old_message_level = MLSUB(gc_message_level,0);
      MLUPDATE(gc_message_level,0,MLINT(-1));
      gc_collect_all();
      MLUPDATE(gc_message_level,0,old_message_level);
    }

    argument = allocate_record(2);
    FIELD(argument, 0) = filename;
    FIELD(argument, 1) = global;
    retract_root(&filename);
    retract_root(&global);

    if(image_save(argument) == MLERROR)
      switch(errno) {
	case EIMPL:
	error("Image saving is not implemented.");

	case EIMAGEOPEN:
	error("The image saver was unable to open the file `%s'.",
	      option_save.arguments[0]);

	case EIMAGEWRITE:
	error("The image saver was unable to write to the file `%s'.",
	      option_save.arguments[0]);

	default:
	error("The image saver returned %d, "
	      "which is not a valid error code.", errno);
      }
  }

  if(option_save_exec.specified)
  {
    mlval global, filename;

    if(option_verbose.specified) {
      message_start();
      message_string("Saving executable image to file `");
      message_string(option_save_exec.arguments[0]);
      message_string("'");
      message_end();
    }

    global = global_pack(0);	/* 0 = not delivery */
    declare_root(&global, 1);
    filename = ml_string(option_save_exec.arguments[0]);
    declare_root(&filename, 1);

    { /* verbosely collect all */
      mlval old_message_level = MLSUB(gc_message_level,0);
      MLUPDATE(gc_message_level,0,MLINT(-1));
      gc_collect_all();
      MLUPDATE(gc_message_level,0,old_message_level);
    }
    retract_root(&filename);
    retract_root(&global);

    if(save_executable(CSTRING(filename), global, APP_CURRENT) == MLERROR)
      switch(errno) {
	case EIMPL:
	error("Executable image saving is not implemented.");

	case EIMAGEOPEN:
	error("The image saver was unable to open the file `%s'.",
	      option_save_exec.arguments[0]);

        case EIMAGEREAD:
	error("The image loader was unable to read from the file `%s' "
	      "despite being able to open it.", runtime);

        case EIMAGEALLOC:
	error("The image loader was unable to allocate enough memory while "
	      "reading the file `%s'.", runtime);

	case EIMAGEWRITE:
	error("The image saver was unable to write to the file `%s'.",
	      option_save_exec.arguments[0]);

	default:
	error("The image saver returned %d, "
	      "which is not a valid error code.", errno);
      }
  }

  return(EXIT_SUCCESS);
}
@


1.11
log
@[Bug #30411]
Add command-line option to behave as Free edition
@
text
@d13 4
d428 1
a428 1
static int start_mlworks(int argc, const char *const *argv)
d880 1
a880 1
  run_scheduler(start_mlworks, argc, argv);
@


1.10
log
@[Bug #50061]
Reverse treatment of command-line argument passing for executables with embedded image
@
text
@d13 4
d93 1
d164 2
d232 1
d270 2
a271 1
 &option_mono, &option_verbose, &option_statistics, &option_help,
d540 7
@


1.9
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@d13 5
d281 6
d420 3
d427 19
a445 1
  if(!option_parse(&argc, &argv, options))
d500 3
d538 2
a539 2
    if (!option_no_load_exec.specified) {
      loaded = load_heap_from_executable(&root, runtime);
@


1.8
log
@[Bug #30134]
add extra arg to save_excutable.
@
text
@d13 4
d731 1
a731 1
    declare_root(&global);
d733 1
a733 1
    declare_root(&filename);
d735 6
a740 6
  { /* verbosely collect all */
    mlval old_message_level = MLSUB(gc_message_level,0);
    MLUPDATE(gc_message_level,0,MLINT(-1));
    gc_collect_all();
    MLUPDATE(gc_message_level,0,old_message_level);
  }
d780 1
a780 1
    declare_root(&global);
d782 1
a782 1
    declare_root(&filename);
@


1.7
log
@[Bug #1833]
Change instances of "modules" in runtime usage message to "object files"
@
text
@d13 4
d789 1
a789 1
    if(save_executable(CSTRING(filename), global) == MLERROR)
@


1.7.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a12 4
 * Revision 1.7  1997/04/11  14:03:22  jont
 * [Bug #1833]
 * Change instances of "modules" in runtime usage message to "object files"
 *
@


1.7.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a12 4
 * Revision 1.7  1997/04/11  14:03:22  jont
 * [Bug #1833]
 * Change instances of "modules" in runtime usage message to "object files"
 *
@


1.7.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a12 4
 * Revision 1.7  1997/04/11  14:03:22  jont
 * [Bug #1833]
 * Change instances of "modules" in runtime usage message to "object files"
 *
@


1.6
log
@[Bug #1925]
stop_mlworks: set the messager_function to NULL before a message
is output so that the message always goes to the tty.
@
text
@d13 5
d86 1
a86 1
  "Usage:   %s [options...] module...\n"
d89 1
a89 1
  " Module Options:\n"
d93 1
a93 1
  "          Load an image from <file> before loading any modules.\n"
d95 1
a95 1
  "          Read module file names from <file> before reading them from\n"
d98 1
a98 1
  "          After loading the specified modules, save the image in <file>.\n"
d101 1
a101 1
  "          modules. <s> may be any string.\n"
d165 1
a165 1
  "          Do not check consistency of module time stamps.\n"
d172 1
a172 1
  "  -show   Display the result of the final module.\n"
@


1.6.1.1
log
@branched from 1.6
@
text
@a12 5
 * Revision 1.6  1997/03/10  09:11:54  stephenb
 * [Bug #1925]
 * stop_mlworks: set the messager_function to NULL before a message
 * is output so that the message always goes to the tty.
 *
@


1.6.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a12 3
 * Revision 1.6.1.1  1997/05/12  10:41:30  hope
 * branched from 1.6
 *
@


1.6.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a12 3
 * Revision 1.6.1.1  1997/05/12  10:41:30  hope
 * branched from 1.6
 *
@


1.6.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a12 3
 * Revision 1.6.1.1  1997/05/12  10:41:30  hope
 * branched from 1.6
 *
@


1.6.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a12 3
 * Revision 1.6.1.1.1.1  1997/07/28  18:25:34  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.5
log
@[Bug #1880]
Remove expiry date protection checking from MLWorks
@
text
@d13 4
d367 1
@


1.4
log
@Change explorer entry.
.,
@
text
@d13 4
a58 1
#include "expiry.h"
a391 2

  check_expiry_date();
@


1.4.5.1
log
@branched from 1.4
@
text
@a12 4
 * Revision 1.4  1996/10/25  15:05:26  nickb
 * Change explorer entry.
 * .,
 *
@


1.4.4.1
log
@branched from 1.4
@
text
@a12 4
 * Revision 1.4  1996/10/25  15:05:26  nickb
 * Change explorer entry.
 * .,
 *
@


1.4.4.2
log
@[Bug 1880]
Remove calls to expiry date protection mechanism
@
text
@a12 3
 * Revision 1.4.4.1  1996/12/17  17:54:30  hope
 * branched from 1.4
 *
d59 1
d393 2
@


1.4.4.2.1.1
log
@branched from 1.4.4.2
@
text
@a12 4
 * Revision 1.4.4.2  1997/01/02  14:46:57  jont
 * [Bug 1880]
 * Remove calls to expiry date protection mechanism
 *
@


1.4.3.1
log
@branched from 1.4
@
text
@a12 4
 * Revision 1.4  1996/10/25  15:05:26  nickb
 * Change explorer entry.
 * .,
 *
@


1.4.2.1
log
@branched from 1.4
@
text
@a12 4
 * Revision 1.4  1996/10/25  15:05:26  nickb
 * Change explorer entry.
 * .,
 *
@


1.4.1.1
log
@branched from 1.4
@
text
@a12 4
 * Revision 1.4  1996/10/25  15:05:26  nickb
 * Change explorer entry.
 * .,
 *
@


1.4.1.2
log
@[Bug #1880]
Remove old expiry date protection mechanism
@
text
@a12 3
 * Revision 1.4.1.1  1996/11/14  12:58:27  hope
 * branched from 1.4
 *
d59 1
d393 2
@


1.4.1.1.1.1
log
@branched from 1.4.1.1
@
text
@a12 3
 * Revision 1.4.1.1  1996/11/14  12:58:27  hope
 * branched from 1.4
 *
@


1.4.1.1.1.2
log
@[Bug #1880]
Remove call to check expiry date
@
text
@a12 3
 * Revision 1.4.1.1.1.1  1996/11/28  15:08:23  hope
 * branched from 1.4.1.1
 *
d62 1
d396 2
@


1.3
log
@[Bug #1693]
Don't hang on license failure when running in batch mode
@
text
@d13 4
d564 1
a569 1
      global_unpack(root);
@


1.2
log
@Merging in license server stuff
@
text
@d13 3
a15 2
<<<<<<< /u/jont/ml/ml_compiler/MLW/src/rts/src:main.c
=======
a24 1
>>>>>>> 1.1.2.3
d432 3
a434 1
  if (!option_batch.specified)
d436 1
@


1.1
log
@new unit
Portable main.c at last.
@
text
@d12 17
a28 1
 *  $Log$
d374 1
d420 1
a420 1
  license();
@


1.1.3.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:main.c,v $
 * Revision 1.1  1996/08/27  16:29:51  nickb
 * new unit
 * Portable main.c at last.
 *
@


1.1.2.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:main.c,v $
 * Revision 1.1  1996/08/27  16:29:51  nickb
 * new unit
 * Portable main.c at last.
 *
@


1.1.2.2
log
@Name change: license -> license_init.
@
text
@a12 3
 * Revision 1.1.2.1  1996/10/07  16:13:15  hope
 * branched from 1.1
 *
d407 1
a407 1
  license_init();
@


1.1.2.3
log
@Release the license when terminating
@
text
@a12 3
 * Revision 1.1.2.2  1996/10/09  12:16:23  nickb
 * Name change: license -> license_init.
 *
a364 1
  license_release();
@


1.1.1.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:main.c,v $
 * Revision 1.1  1996/08/27  16:29:51  nickb
 * new unit
 * Portable main.c at last.
 *
@
