head	1.1;
access;
symbols
	MLWorks_21c0_1999_03_25:1.1
	MLWorks_20c1_1998_08_20:1.1
	MLWorks_20c0_1998_08_04:1.1
	MLWorks_20b2c2_1998_06_19:1.1
	MLWorks_20b2_Windows_1998_06_12:1.1
	MLWorks_20b1c1_1998_05_07:1.1
	MLWorks_20b0_1998_04_07:1.1
	MLWorks_20b0_1998_03_20:1.1
	MLWorks_20m2_1998_02_16:1.1
	MLWorks_20m1_1997_10_23:1.1
	MLWorks_11r1:1.1.1.1.1.1.1
	MLWorks_11c0_1997_09_09:1.1.1.1.1.1
	MLWorks_10r3:1.1.1.1.3
	MLWorks_10r2_551:1.1.1.1.2
	MLWorks_11:1.1.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.1.1.1
	MLWorks_20m0_1997_06_20:1.1
	MLWorks_1_0_r2c2_1997_06_14:1.1.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.1.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.1.1
	MLWorks_BugFix_1997_04_24:1.1
	MLWorks_1_0_r2_Win32_1997_04_11:1.1
	MLWorks_1_0_r2_Unix_1997_04_04:1.1;
locks; strict;
comment	@# @;


1.1
date	97.01.10.17.35.27;	author andreww;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.12.10.25.28;	author hope;	state Exp;
branches
	1.1.1.1.1.1
	1.1.1.1.2.1
	1.1.1.1.3.1;
next	;

1.1.1.1.1.1
date	97.07.28.18.11.24;	author daveb;	state Exp;
branches
	1.1.1.1.1.1.1.1;
next	;

1.1.1.1.1.1.1.1
date	97.10.07.11.36.14;	author jkbrook;	state Exp;
branches;
next	;

1.1.1.1.2.1
date	97.09.08.17.04.42;	author daveb;	state Exp;
branches;
next	;

1.1.1.1.3.1
date	97.09.09.13.59.50;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
[Bug #1818]
documentation for implementation of floatarrays
@


1.1
log
@new unit
[Bug #1818]
documentation for implementation of floatarrays
@
text
@% .floatarray.doc
%
% INTERNAL DOCS ON THE IMPLEMENTATION OF FLOATARRAYS
% Andrew Wilon, Jan 6th 1997
%
% Copyright (C) 1997 Harlequin Ltd.
%
% Revision Log
% ------------
% $Log:,v$
%

.overview:

Overview
--------

Standard arrays are represented as sequences of references to data items.
Thus an array of reals of size n would be represented as:

	header word, followed by n words

where the size of the array is store in the header, and where each
word points to a separate floating point value.  The internal
representation of a floating point value takes four words (on a
SPARC...).  These consist of:

	0		1		2,3
	header word	dummy word	8 bytes of actual data

Where the dummy word is used to maintain double-word alignment for
floats.

Therefore, one can see that each entry in an array of reals requires
20 bytes.  (Of course, if many of the entries are identical, then
these may be pointed to by the same reference, thereby saving space:
an array of n 0.0s will only require n words plus sixteen bytes for
the 0.0 value).

This is wasteful for those applications which require non-sparse
arrays.  In this scheme, it would be better simply to allocate a
sequence of 8-byte chunks, one for each entry in the array.  Thus a
floatarray of n floats would have the following representation:

	1		2	3,4 ...
	header word	dummy	n*8 bytes

Where the dummy word is again to maintain double-word alignment.

To implement this, we require the following built-in operations:

	* create array			            FLOATARRAY
	* return length			            FLOATARRAY_LENGTH
	* index into array (with bounds checking)   FLOATARRAY_SUB
	* index into array (unsafely)		    FLOATARRAY_UNSAFE_SUB
	* update array	   (with bounds checking)   FLOATARRAY_UPDATE
	* update array 	   (unsafely)		    FLOATARRAY_UNSAFE_UPDATE


.contents:


Contents of document:

	1 .MIR-code
	2 .Adding-builtins
	3 .performance

   ----------------------------------------------------------------------

.MIR-code:


1. MIR Code implementation
--------------------------

Files:	mir/_mir_cg.sml


Essentially, floatarrays are implemented as bytearrays, which are just
sequences of bytes offset by a header word.  The first word of the
byte array is its header, the second word is a dummy, and the next n
bytes are sequences of floating point values.

Note that the header of the bytearray is regarded as the header of the
floatarray, so in particular the size of a floatarray is given in
bytes (i.e., we always have to divide it by 8, or right-shift its
binary rep by 3) to get the number of floats.

With this in mind, the implementation of the builtin operators becomes
straightforward.  In _mir_cg, we include the following functions:

	floatarray_code
	floatarray_sub_code
	floatarray_update_code

and alter the following function: length_code.  (This function is used
to calculate the lengths of both bytearrays and ordinary arrays from
the header word.  The alteration is simply to divide the length of a
bytearray by 8 if it codes a floatarray.)

There is nothing very surprising/no clever hackery (at least none that
isn't commented) in the code which is actually generated by these
functions.  The routines do what you would expect:

      . floatarray_code allocates the required space and then
	initializes the contents appropriately.

      . floatarray_sub_code first (if in safe mode) generates code
	to check array bounds, and then looks up the required
	value by performing typical address arithmetic (i.e., add
	n*8 bytes to the start of the first word...)

      . floatarray_update_code similarly first (if in safe mode)	
	generates code to check array bounds, then calculates the
	required offset into the array, and then stores the
	required value therein.

The functions take different arguments, but they each share these three:

	regs, 	the_code, exn_code

The first is a list of registers that contain the arguments that will
be passed to the code creation routines.  For floatarray_code, the two
arguments (size and initial value) can either be passed as a pair or
as a pointer to a piece of memory where they are located.

	the_code is the list of code generated before the current call
		 is made to floatarray_code (i.e., to which the current
		 code is appended).

	exn_code contains the current code for exception handling.

The only hack worth mentioning concerns the magic numbers which appear
as offsets to the store and load operations.  This is to counteract the
effects of tagging (see <URI:rts/src/tags.h>).  Thus, a pointer has tag
5, which means that the address it points to will be offset by 5.




.Adding-builtins:

2. Adding new builtins to the pervasive library
-----------------------------------------------


Files:	stage 1: (behind the scenes)
	  main/[_]pervasives.sml
	  typechecker/[_]types.sml
	  typechecker/_tyenv.sml
	  lambda/_simpleutils.sml
	  sparc/_machperv.sml
	  mips/_machperv.sml
	  i386/_i386perv.sml

	stage 2: (supplying the builtins)
	  pervasive/__builtin_library.sml
	  pervasive/floatarray.sml
	  pervasive/mlworks.sml
	  pervasive/__pervasive_library.sml
	  debugger/_value_printer.sml
	  interpreter/interpreter.sml
	  interpreter/xinterpreter.sml

.behind-the-scenes:


STAGE ONE: behind the scenes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The first step is to modify main/[_]pervasives.sml.  This comprises three
steps:

.new-values:

	First, provide atomic constructors for the new pervasives.
	(FLOATARRAY, FLOATARRAY_LENGTH, ... etc.)

	Second, extend the function print_pervasive to handle these
	new constructors.

	Third, extend the list called "value_name_list" with pairs
	that associate the new pervasives with the names of the
	functions they will implement in the __builtin_library: e.g.,
	the pair

		(FLOATARRAY,"floatarray")

	associates the builtin operation FLOATARRAY with the builtin
	function "floatarray" in __builtin_library.sml.  Note that
	in this stage no such function actually exists in the builtin
	library.  However, they will do at the end of the second stage.

	This list is then sorted alphabetically according to the
	function name, from which we can associate a number to each
	builtin, according to the position in which it occurs in the
	sorted list.

	Note that this list is subsequently used by the typechecker
	to construct initial environments for the builtin library, which
	are then used to pull the required values into the top level.
	(See later for more details.)

.new-type:

The second step (after hooking the actual code generation routines
to their pervasives in the case statement "case prim of" in
mir/_mir_cg.sml) is to provide the builtin floatarray type.  This
again consists of three steps:

	First, we create a new tyname for floatarrays.  This is done
	simply by adding the line

	val floatarray_tyname = make_tyname(0,true,"floatarray",NONE,0)
	
		(i.e., the floatarray type has arity 0,
					   has equality,
					   has name "floatarray",
					   has no compiler location
					    (it hasn't been compiled
					     from a piece of source code)
					   has level 0
					    (see <URI:typechecker_levels.doc>))

	to typechecker/_types.sml, (and also adding floatarray_tyname
	to the signature in typechecker/types.sml).

	Second, we must say what kind of equality it has (it has reference
	equality), so we add the clause
	
		orelse tyname_eq(floatarray_tyname,tyname)

	to the function has_ref_equality in typechecker/_types.sml.

	Third, we must add the tyname to the initial type environment
	(i.e., the one for the builtin library.)  This is done in
	typechecker/_tyenv.sml, in the code defining

		initial_te_for_builtin_library
	

The third step is to ensure that the new pervasive constructors are
not overlooked by other functions (thereby raising a Match exception
whenever a function is applied to a new pervasive).  The relevant
files are:

	lambda/_simpleutils.sml
	sparc/_machperv.sml
	mips/_machperv.sml
	i386/_i386perv.sml

And we simply copied and modified the relevant entries for the
ByteArray builtins.



.supplying-the-builtins:


STAGE TWO: supplying the builtins
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

At this point, we have to rebuild the compiler, so that the builtin
types, etc. are known to the compiler, even though they do not appear
at the top level.  Thus when we next come to rebuild the compiler
(when the pervasive library has been altered) the builtins will exist.


The first step is to alter the file pervasive/__builtin_library.sml to
supply the new type and functions.  Note that both the signature and
structure of the library are contained in this file, and that both
have to be altered.  It is at this stage that the type of the new
functions are given.  For instance, to add the floatarray creation
builtin, we use:

      val floatarray : int * real -> floatarray =
                                            no  "floatarray"

Where the function "no" raises the LibraryError exception with
its own argument.  This is a bit of compiler magic which we explain
below in .LibraryError.


The second step is to pull these builtins into the pervasive library
proper.  The purpose of the builtin library is (essentially) to make
those functions which are built-in to the compiler itself callable as
ML functions.  The pervasive library picks those builtins which it
wishes to make toplevel, and packages them up into the appropriate
structures.  For floatarrays, this involves adding a new floatarray
signature file (like the array and bytearray signatures), altering the
mlworks.sml file, which provides the interface for the top-level
MLWorks structure, and the __pervasive_library.sml file itself to
implement the required files on top of the builtins.  This stage is
quite straightforward.

The last step is to alter the code in debugger/_value_printer.sml to
provide code for printing the value of floatarrays.  This code
essentially mimics that for printing arrays and bytearrays.  The main
difference is that these last two pieces of code invoke the runtime to
extract the required values, whereas the floatarray printing code uses
the builtins.


.pervasives-in-images:

Adding an extra file (the floatarray signature file) into the
pervasive library affects the image build process.  Building an image
(e.g., batch.img, gui.img etc.) consists of loading many
separate-compilation units, and then saving the result.  Note that any
expressions that are to be evaluated in a unit will be executed as
soon as the image is run.  (Hence in gui.img, the interpreter will be
executed when the image is run, since it is invoked in
interpreter/xinterpreter.sml).

Most of the units required to build the gui.img are only needed to
actually build the image, so they can be removed before starting the
interpreter. However, the pervasive units are required to load object
files (see the comment in interpreter/xinterpreter.sml).  Thus the
files interpreter/interpreter.sml and interpreter/xinterpreter.sml
both contain code to remove all but the pervasive units from the
Runtime modules.

Since we have added a new file to the pervasives (floatarray.sml), we
have increased the number of pervasive units at runtime, and so must
instruct the interpreter to keep one more unit.  The change for this is
to alter the line

	val _ = MLWorks.Internal.Runtime.modules :=
		last(10,!MLWorks.Internal.Runtime.modules)

in both interpreter/interpreter.sml and interpreter/xinterpreter.sml
to increase the magic constant 10 to 11.  (This constant should equal
the number of .sml files in the pervasive source directory.)




.LibraryError:

How the Builtins are connected to ML functions
- - - - - - - - - - - - - - - - - - - - - - - -

We mentioned above that the code for the builtins given in
__builtin_library.sml gives a dummy body to the function.  Thus
for the floatarray creation builtin, we have

	val floatarray: int * real -> floatarray = no "floatarray"

where the no function simply raises LibraryError.  This exception is
not handled anywhere in the code, the reason being that this dummy
body is never called: after the builtin library is compiled, the
compiler substitutes its own code.

The actual substitution is performed in interpreter/_incremental.sml.
After compiling __builtin_library.sml, it replaces the lambda
environment (i.e., the environment that maps values to their lambda
code) with the environment builtin_lambda_environment which is
constructed in main/_compiler.sml:

	   val builtin_top_env = 
		EnvironTypes.TOP_ENV (Primitives.env_after_builtin,
				      Environ.empty_fun_env)

Where Primitives.env_after_builtin is defined in main/_primitives.sml:

	   val initial_env =
	      add_vals
	      (add_exns
               (add_cons (Environ.empty_env, 
 		  map (fn (x,y) => (y,x)) Pervasives.constructor_name_list), 
	         map (fn (x,y) => (y,x)) Pervasives.exception_name_list), 
	       map (fn (x,y) => (y,x)) Pervasives.value_name_list)

	   val env_after_builtin =
	      Environ.add_strid_env
	       (Environ.empty_env,
	        (builtin_library_strname,  (* = "BuiltinLibrary_" *)
	          (initial_env, EnvironTypes.FIELD {index=0,size=1}, false)))

And the various name_lists are defined in main/_pervasives.sml, the list
which we altered to add the new builtins.

This associates the various functions with the names of the builtins
given in main/_pervasives.sml.  The actual translation from name to
Mir code is done in _mir_cg.sml, as noted briefly above.




.performance:

3. A Few Performance Measurements
---------------------------------

This lists a few experimental checks done to determine the relative
space and time characteristics between floatarrays and arrays of real.

SPACE allocated/copied:

	Creating an array of 1000000 floats, all equal to 0.0:

	array of real:	3Mb 854296 bytes / 8 bytes
	floatarray:	7Mb 659984 bytes / 8 bytes

	An array of 1000000 floats, all different:

	array of real:	19Mb 77096 bytes / 29Mb 980712 bytes
	floatarray:	7Mb 660000 bytes / 8 bytes

TIME: 
  (Note that to avoid cache effects, the arrays have to be initialised
   so that every entry is distinct.)

  1. Summing the elements of an array of 1000000 floats 100 times:


			SPARC(SunOS)	MIPS		i386*
	array of real:  90.53s		40.09s		75.97s
	floatarray:	60.18s		29.77s		48.92s


  2. Copying the elements of an array of 1000000 floats 100 times:

			SPARC(SunOS)	MIPS		i386*
	array of real:  80.89s		41.39s		29.49s
	floatarray:	79.87s		50.26s		46.31s

			We should expect array of real to be faster
			here, since it will not involve unboxing (it
			will only copy the pointers to the floats)

  3. Applying the floor operation to each element of an array of 
     1000000 floats (and ignoring the answers) 100 times:

			SPARC(SunOS)	MIPS		i386*
	array of real:	178.33S		78.57s		71.86s
	floatarray:	144.78s		64.20s		57.89s


--------------
* Note that the tests on the i386 are the only ones that incurred gc time.
  the times given above are the times after the gc has been removed.
@


1.1.1.1
log
@branched from 1.1
@
text
@d10 1
a10 6
% $Log: floatarray.doc,v $
# Revision 1.1  1997/01/10  17:35:27  andreww
# new unit
# [Bug #1818]
# documentation for implementation of floatarrays
#
@


1.1.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a10 3
# Revision 1.1.1.1  1997/05/12  10:25:28  hope
# branched from 1.1
#
@


1.1.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a10 3
# Revision 1.1.1.1  1997/05/12  10:25:28  hope
# branched from 1.1
#
@


1.1.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a10 3
# Revision 1.1.1.1  1997/05/12  10:25:28  hope
# branched from 1.1
#
@


1.1.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a10 3
# Revision 1.1.1.1.1.1  1997/07/28  18:11:24  daveb
# branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
#
@
