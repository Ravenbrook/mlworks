<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1977) -->
<HEAD>
<LINK REL=TOP HREF="UG_1.HTM">
<LINK REL=UP HREF="UG_4.HTM">
<LINK REL=PREV HREF="UG_7.HTM">
<LINK REL=NEXT HREF="UG_9.HTM">
<TITLE>1.4   Introducing the listener</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1977)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING8></A>

<DIV>
<P><A HREF="UG_9.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="UG_7.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="UG_4.HTM"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="UG_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="UG_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="UG_85.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>1 Using MLWorks interactively</P>

</DIV>
<A NAME=HEADING8-0></A>
<A NAME=UID-listener-853846></A>
<H1>1.4   <A NAME=MARKER-9-194></A>Introducing the listener</H1>
<P>The first thing you need to run MLWorks interactively is a <A NAME=MARKER-2-195></A>listener, a tool that is automatically createdwhen you run MLWorks<A NAME=MARKER-10-196></A>. This tool gives you an ML command line at which you can type expressions. </P>
<P>You can also create a listener by choosing <B>Tools &gt; Listener</B> from the podium<A NAME=MARKER-10-197></A>. A listener appears, with the following prompt:</P>
<PRE>
MLWorks&gt; 
<P></P>
</PRE>
<P><A NAME=MARKER-10-198></A><IMG ALIGN=TOP SRC=UG8IMAG3.GIF></P>
<P>Figure 1.2   The MLWorks listener.</P>
<P>You can exit any listener window with <B>File &gt; Close</B> or with the function <CODE>Shell.exit</CODE>.<B> </B></P>
<P><B><A NAME=MARKER-10-199></A></B><A NAME=MARKER-2-200></A>At the heart of the listener is a <I>read-eval-print loop</I> which reads input typed at the prompt, evaluates it, and prints the result. If you type an expression, the result is just the value of the expression:</P>
<PRE>
MLWorks&gt; (7 * 4) - 3;
val it : int = 25
MLWorks&gt; 
<P></P>
</PRE>
<P>Remember to terminate each line of input with the Return (or Enter) key -- in this example, after the semi-colon. MLWorks does not read the line until it is terminated in this way, or equivalently by pressing the <B>Evaluate</B> button at the bottom of the listener. </P>
<P><B>Note:</B> The MLWorks system compiles <I>all</I> code, never interpreting as some other languages, such as Lisp, do. The listener, with its Lisp-like read-eval-print operation model, may seem like an interpreter, but in fact everything it accepts is evaluated by being compiled down to native code. </P>
<P><B>Note</B>: In Standard ML, an expression encountered at top level is treated as an implicit declaration, binding the identifier <CODE>it</CODE> to the given expression. From here on, when we refer to a "declaration" typed in the listener, we include an expression typed at top level. The result of evaluating an expression, shown above, is in fact just a special case of the evaluation of a declaration, which we examine next.</P>
<P>If you type an explicit declaration in the listener, MLWorks binds the identifier to the given value and verifies the declaration and its type. For example, we can bind the identifier <CODE>five</CODE> to the value 5, declare an exception <CODE>Fact</CODE>, and define <CODE>fact</CODE> to be the usual factorial function:</P>
<PRE>
MLWorks&gt; val five = 5; 
val five : int = 5 
MLWorks&gt; exception Fact; 
exception Fact 
MLWorks&gt; fun fact 0 = 1 
           | fact n = if n&lt;0 then raise Fact 
                      else n * fact (n-1); 
val fact : int -&gt; int = fn 
MLWorks&gt; 
<P></P>
</PRE>
<P>The last example shows another feature of the listener, namely that it accepts declarations typed over multiple lines. It reads and parses lines in turn as they are typed, but it does not attempt to evaluate a declaration until it encounters the semi-colon that terminates the declaration. When MLWorks reads a line containing the terminating semi-colon, it interprets everything since the last evaluation as a declaration (or series of declarations). </P>
<P>Once a value has been bound to an identifier, that binding holds in your MLWorks session unless it is overridden by a later binding.<A NAME=MARKER-2-201></A></P>
<P>The binding can be used in subsequent declarations:</P>
<PRE>
MLWorks&gt; fact five;
val it : int = 120
MLWorks&gt; val five = 6;
val five : int = 6
MLWorks&gt; fact five;
val it : int = 720
MLWorks&gt; 
<P></P>
</PRE>
<P>If you type a declaration in the window and press the <B>Time</B> button, MLWorks will evaluate the declaration as normal, and also give a line of information about how long the evaluation took. For much more complicated profiling of ML functions, you can use the MLWorks profiler tool, invoked with the <B>Profile</B> button. There is also programmatic interface to the profiler in the <CODE>MLWorks.Profile</CODE> and <CODE>Shell.Profile</CODE> structures: for details, see the <I>MLWorks Reference Manual</I>. </P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>MLWorks User Guide version 2.0 for Windows - 30 Jul 1998</ADDRESS>
<P><A HREF="UG_9.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="UG_7.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="UG_4.HTM"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="UG_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="UG_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="UG_85.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>Generated with <A HREF="http://www.harlequin.com/webmaker/">Harlequin WebMaker</A></P>

</DIV>
</BODY>
</HTML>
