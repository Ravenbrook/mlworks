head	1.2;
access;
symbols
	MLWorks_21c0_1999_03_25:1.2
	MLWorks_20c1_1998_08_20:1.2
	MLWorks_20c0_1998_08_04:1.2
	MLWorks_20b2c2_1998_06_19:1.2
	MLWorks_20b2_Windows_1998_06_12:1.2;
locks; strict;
comment	@ * @;


1.2
date	98.06.11.13.38.22;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	98.06.10.17.12.57;	author jont;	state Exp;
branches;
next	;


desc
@new unit
Adding applications into hope and daily
@


1.2
log
@Automatic checkin:
changed attribute _comment to ' * '
@
text
@(*
 *
 * $Log$
 *
 *)
functor Env (structure V  : VAR;
             structure SL : SORTEDLIST ) : ENV =
struct
   structure V = V

   type 'a env = (V.var * 'a) list

   exception Unbound of V.var

   val empty   = []
   val isempty = Lib.isnil

   fun key_le ((x,_),(y,_)) = V.le(x,y)

   fun lookup (x,e) = ( Lib.snd(SL.retrieve Lib.fst V.le (x,e))
                        handle SL.Retrieve => 
			    let (* val _ = 
				 print ("*** " ^ 
					(V.mkstr x) ^ 
					 " is unbound! ***\n") *)
			     in
				 raise (Unbound x)
			     end )

   fun bind (v,a,e) = SL.add key_le true ((v,a),e)
   val unbind = fn x => SL.remove Lib.fst V.le x

   val map = Lib.map

   val forall = Lib.forall
   val exists = Lib.exists

   val merge = fn x => SL.merge key_le true x

   fun getvars e = Lib.map Lib.fst e

(************************************************************************)
(*  str0 : preamble                           str2 : between bindings   *)
(*  str1 : between variable and object        str3 : postamble          *)
(************************************************************************)

   fun mkstr _ [] _ = ""
     | mkstr mkstrelt l (str0,str1,str2,str3) =
       str0^(Lib.mkstr (fn (x,a) => (V.mkstr x)^str1^(mkstrelt a)) str2 l)^str3

(*****************************************************************************)
(*  printing function for environment when variable names not required       *)
(*****************************************************************************)

   fun mkstr2 mkstrelt = Lib.mkstr (mkstrelt o Lib.snd) ""

   fun eq elt_eq = Lib.eq (fn ((x,a),(y,b)) => V.eq(x,y) andalso elt_eq(a,b))

   fun le elt_le =
       let fun bind_le ((x,a),(y,b)) =
               V.le(x,y) andalso (not(V.le(y,x)) orelse elt_le(a,b))
        in SL.le bind_le
       end
end

@


1.1
log
@new unit
Adding applications into hope and daily
@
text
@@
